source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
ternary(mod$W, colour = group)
mod$obj
mod$@
mod$W
maxiter = 1000
tol = 1e-6
ridge = 1e-8
mod$H
n <- dim(x)[1]
D <- dim(x)[2]
# Initialize W and H randomly and normalize to simplex
W <- matrix(Rfast2::Runif(n * k), nrow = n, ncol = k)
k=3
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
ternary(mod$W, colour = group)
n <- dim(x)[1]
D <- dim(x)[2]
# Initialize W and H randomly and normalize to simplex
W <- matrix(Rfast2::Runif(n * k), nrow = n, ncol = k)
W <- W / Rfast::rowsums(W)
H <- matrix(Rfast2::Runif(k * D), nrow = k, ncol = D)
H <- H / Rfast::rowsums(H)
prev.obj <- NULL
# Setup for H update (each column on simplex)
Aeq_H   <- rep(1, k)
Aineq_H <- diag(k)
Amat_H  <- cbind(Aeq_H, Aineq_H)
bvec_H  <- c(1, rep(0, k))
meq     <- 1
ridgeK <- ridge * Aineq_H
# Setup for W update (each row on simplex)
Aeq_W   <- rep(1, k)
Aineq_W <- diag(k)
Amat_W  <- cbind(Aeq_W, Aineq_W)
bvec_W  <- c(1, rep(0, k))
## Update H: each COLUMN on simplex
WtW <- crossprod(W)           # k x k
WtX <- crossprod(W, x)        # k x D
DmatH <- 2 * WtW + ridgeK
d=1
dvec <- 2 * WtX[, d]        # gradient for column d
sol <- try(
solve.QP(Dmat = DmatH, dvec = dvec, Amat = Amat_H,
bvec = bvec_H, meq = meq)$solution,
silent = TRUE
)
sol
dvec <- 2 * WtX[, d]        # gradient for column d
sol <- try(
quadprog::solve.QP(Dmat = DmatH, dvec = dvec, Amat = Amat_H,
bvec = bvec_H, meq = meq)$solution,
silent = TRUE
)
sol
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
ternary(mod$W, colour = group)
mod$obj
