saa.qp <- function(x, k, maxiter = 1000, tol = 1e-6, ridge = 1e-8) {
  n <- dim(x)[1]  ;  D <- dim(x)[2]
  # initialize W and H randomly and normalize
  W <- matrix( Rfast2::Runif(n * k), nrow = n, ncol = k)
  W <- W / Rfast::rowsums(W)
  H <- matrix( Rfast2::Runif(k * D), nrow = k, ncol = D)
  H <- H / Rfast::rowsums(H)  ## FIX: rows sum to 1, not columns
  prev.obj <- NULL
  Aeq   <- rep(1, D)  ## FIX: constraint dimension is D now, not k
  Aineq <- diag(D)    ## FIX: D x D identity
  Amat  <- cbind(Aeq, Aineq)
  bvec  <- c(1, rep(0, D))  ## FIX: length D+1
  meq   <- 1
  ridgeD <- ridge * diag(D)  ## FIX: ridge for D-dimensional problem
  ridgeK <- ridge * diag(k)  ## ridge for k-dimensional problem (W update)

  for ( it in 1:maxiter ) {
    ## Update H: each row on simplex
    WtX <- crossprod(W, x)  # k x D
    for ( j in 1:k ) {  ## FIX: loop over rows, not columns
      w_j <- W[, j]  # column j of W (n-vector)
      norm_sq <- sum(w_j^2)
      DmatH <- 2 * norm_sq * diag(D) + ridgeD
      g <- -2 * WtX[j, ]  # gradient for row j
      sol <- try( solve.QP(Dmat = DmatH, dvec = -g, Amat = Amat, bvec = bvec, meq = meq)$solution,
                  silent = TRUE )
      if ( inherits(sol, "try-error") || any(!is.finite(sol)))  sol <- rep(1/D, D)  # fallback to barycenter
      H[j, ] <- sol  ## FIX: update row j
    }

    ## Update W: each row on simplex (this part was already correct)
    HHt <- tcrossprod(H) ;  HHt <- matrix(HHt, k, k)
    DmatW <- 2 * HHt + ridgeK
    Aeq_W   <- rep(1, k)
    Aineq_W <- diag(k)
    Amat_W  <- cbind(Aeq_W, Aineq_W)
    bvec_W  <- c(1, rep(0, k))
    for ( i in 1:n ) {
      g <-  -2 * drop(H %*% x[i, ])
      sol <- try( solve.QP(Dmat = DmatW, dvec = -g, Amat = Amat_W, bvec = bvec_W, meq = meq)$solution,
                  silent = TRUE )
      if ( inherits(sol, "try-error") || any(!is.finite(sol)) )  sol <- rep(1/k, k)
      W[i, ] <- sol
    }

    obj <- sum( (x - W %*% H)^2 )
    if ( is.null(prev.obj) ) {
      relchg <- Inf
    } else {
      relchg <- abs(prev.obj - obj) / (1 + prev.obj)
      if ( !is.finite(relchg) ) relchg <- Inf
    }
    if ( relchg < tol ) break
    prev.obj <- obj
  }

  list(W = W, H = H, obj = obj, iters = it)
}
